<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一个简单的识别是否有猫的神经网络(吴恩达老师的作业）]]></title>
    <url>%2F2018%2F01%2F28%2F201801281920%2F</url>
    <content type="text"><![CDATA[一、环境本次程序均在Jupyter中进行编写。 可直接安装Anaconda3就可以了。 二、介绍本神经网络类似于一开始的那一张图片。 仅有一个神经元节点（我是这么理解的，可能与正式的称呼不同） 神经网络的输入为一张图片 纬度为 64643 = 12288 输入的矩阵的shape为[12288,1] 激活函数函数采用sigmoid函数 三、源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#导入相关库 其中lr_utils以及相关数据集如果有需要可以联系我import numpy as np import matplotlib.pyplot as plt import h5py import scipy from PIL import Image from scipy import ndimage from lr_utils import load_dataset#matplotlib inline# Loading the data (cat/non-cat) train_set_x_orig, train_set_y, test_set_x_orig, test_set_y, classes = load_dataset()m_train = train_set_x_orig.shape[0] #训练集的数量m_test = test_set_x_orig.shape[0] #测试集的数量num_px = train_set_x_orig.shape[1] #输入的矩阵的一个维度#A trick when you want to flatten a matrix X of shape (a,b,c,d) to #a matrix X_flatten of shape (b * c *d, a) is to use:#X_flatten = X.reshape(-1,X.shape[0])#获得测试集与训练集的输入矩阵train_set_x_flatten = train_set_x_orig.reshape(train_set_x_orig.shape[0],-1).Ttest_set_x_flatten = test_set_x_orig.reshape(test_set_x_orig.shape[0],-1).T#将输入矩阵正则化train_set_x = train_set_x_flatten/255test_set_x = test_set_x_flatten/255#sigmoid函数，输入一个np的矩阵，返回对输入矩阵每一个元素计算后的矩阵def sigmoid(x): s=1/(1+np.exp(-x)) return s#w与b的初始化，其中在此网络中w为一个矩阵，b利用广播技术。#输入为输入矩阵的维度，返回w，bdef initialize_with_zeros(dim): w = np.zeros((dim,1)) b = 0 assert(w.shape == (dim, 1)) assert(isinstance(b, float) or isinstance(b, int)) return w, b#前向传播中激活值、cost的计算以及反向传播中dw，db的计算#输入为权重w，偏置b，输入矩阵X，结果矩阵Y#返回为 grads=&#123;&quot;dw&quot;: dw, &quot;db&quot;: db&#125;，costdef propagate(w, b, X, Y): m = X.shape[1] A = sigmoid(np.dot(w.T,X)+b) # compute activation cost = -(np.dot(Y,np.log(A.T))+np.dot(np.log(1-A),(1-Y).T))/m dw = np.dot(X,(A-Y).T)/m db = np.sum(A-Y)/m assert(dw.shape == w.shape) assert(db.dtype == float) cost = np.squeeze(cost) assert(cost.shape == ()) grads = &#123;&quot;dw&quot;: dw, &quot;db&quot;: db&#125; return grads, cost#优化函数，进行参数学习优化#输入为w，b，X，Y,学习次数，学习率，是否每百次输出cost#返回值为学习后的params = &#123;&quot;w&quot;: w, &quot;b&quot;: b&#125;，#grads = &#123;&quot;dw&quot;: dw, &quot;db&quot;: db&#125;，costs（每百次学习的cost）def optimize(w, b, X, Y, num_iterations, learning_rate, print_cost = False): costs = [] for i in range(num_iterations): grads, cost = propagate(w, b, X, Y) dw = grads[&quot;dw&quot;] db = grads[&quot;db&quot;] w = w-learning_rate*dw b = b-learning_rate*db if i % 100 == 0: costs.append(cost) if print_cost and i % 100 == 0: print (&quot;Cost after iteration %i: %f&quot; %(i, cost)) params = &#123;&quot;w&quot;: w, &quot;b&quot;: b&#125; grads = &#123;&quot;dw&quot;: dw, &quot;db&quot;: db&#125; return params, grads, costs#预测函数，学习后进行验证测试def predict(w, b, X): m = X.shape[1] Y_prediction = np.zeros((1,m)) w = w.reshape(X.shape[0], 1) A = sigmoid(np.dot(w.T,X)+b) for i in range(A.shape[1]): if A[0][i]&lt;=0.5: A[0][i]=0 else: A[0][i]=1 Y_prediction=A assert(Y_prediction.shape == (1, m)) return Y_prediction#定义自己的训练模型#输入为训练集的x，训练集的label，测试集的x，测试集的label，学习次数，学习率，是否百次输出#返回为一个dict： ddef model(X_train, Y_train, X_test, Y_test, num_iterations = 2000, learning_rate = 0.5, print_cost = False): w, b = initialize_with_zeros(X_train.shape[0]) parameters, grads, costs = optimize(w, b, X_train, Y_train, num_iterations, learning_rate, print_cost) w = parameters[&quot;w&quot;] b = parameters[&quot;b&quot;] Y_prediction_test = predict(w, b, X_test) Y_prediction_train = predict(w, b, X_train) print(&quot;train accuracy: &#123;&#125; %&quot;.format(100-np.mean(np.abs(Y_prediction_train - Y_train)) * 100)) print(&quot;test accuracy: &#123;&#125; %&quot;.format(100-np.mean(np.abs(Y_prediction_test - Y_test)) * 100)) d = &#123;&quot;costs&quot;: costs, &quot;Y_prediction_test&quot;: Y_prediction_test, &quot;Y_prediction_train&quot; : Y_prediction_train, &quot;w&quot; : w, &quot;b&quot; : b, &quot;learning_rate&quot; : learning_rate, &quot;num_iterations&quot;: num_iterations&#125; return d d = model(train_set_x, train_set_y, test_set_x, test_set_y, num_iterations = 2000, learning_rate = 0.005, print_cost = True)costs = np.squeeze(d[&apos;costs&apos;]) plt.plot(costs) plt.ylabel(&apos;cost&apos;) plt.xlabel(&apos;iterations (per hundreds)&apos;) plt.title(&quot;Learning rate =&quot; + str(d[&quot;learning_rate&quot;]))plt.show() 四、训练结果12345678910111213141516171819202122Cost after iteration 0: 0.693147Cost after iteration 100: 0.584508Cost after iteration 200: 0.466949Cost after iteration 300: 0.376007Cost after iteration 400: 0.331463Cost after iteration 500: 0.303273Cost after iteration 600: 0.279880Cost after iteration 700: 0.260042Cost after iteration 800: 0.242941Cost after iteration 900: 0.228004Cost after iteration 1000: 0.214820Cost after iteration 1100: 0.203078Cost after iteration 1200: 0.192544Cost after iteration 1300: 0.183033Cost after iteration 1400: 0.174399Cost after iteration 1500: 0.166521Cost after iteration 1600: 0.159305Cost after iteration 1700: 0.152667Cost after iteration 1800: 0.146542Cost after iteration 1900: 0.140872train accuracy: 99.04306220095694 %test accuracy: 70.0 % 训练集的准确率为99%测试集的准确率为70% 五、总结这一个神经网络因为参考了吴恩达老师的作业，所以只是按葫芦画瓢进行，自己思考的部分不是很多。 1、输入矩阵要进行正则化，因为只有在sigmoid函数的输入靠近0时才可以有优秀的学习效率 2、矩阵的维度一定要正确，可以自己进行手写一遍进行确认。 3、w的初始化不可以直接用0，虽然本例子中没有太大影响，但是由视频学习可知这是不可以的，因为这样会使每一个单元进行相同的计算。 尽管只有一个神经单元但是这个网络任然达到了70%的识别率，可以相信如果我们不断的改善我们的神经网络，我们可以获得一个优秀的识别模型 希望以后我可以一直加油]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习 字符串和编码]]></title>
    <url>%2F2017%2F05%2F24%2F201705241542%2F</url>
    <content type="text"><![CDATA[前言由于挑战杯项目需要使用到Python，并且在大一时学习树莓派时学习过一定的关于Python的一些知识。现在随着知识的增多见识的增长，发现Python确实是一门很好的高级语言可以做到很多事情，也相对很流行，于是萌发了系统的学习Python的念头。 由于已经了c/c++的基础，所以这次学习选择了廖雪峰老师的Python教程 廖雪峰老师的个人网站地址为：传送门 Python简介Python是著名的“龟叔”Guido van Rossum在1989年圣诞节期间，为了打发无聊的圣诞节而编写的一个编程语言。 现在，全世界差不多有600多种编程语言，但流行的编程语言也就那么20来种。如果你听说过TIOBE排行榜，你就能知道编程语言的大致流行程度。 总的来说，这几种编程语言各有千秋。C语言是可以用来编写操作系统的贴近硬件的语言，所以，C语言适合开发那些追求运行速度、充分发挥硬件性能的程序。而Python是用来编写应用程序的高级编程语言。 当你用一种语言开始作真正的软件开发时，你除了编写代码外，还需要很多基本的已经写好的现成的东西，来帮助你加快开发进度。比如说，要编写一个电子邮件客户端，如果先从最底层开始编写网络协议相关的代码，那估计一年半载也开发不出来。高级编程语言通常都会提供一个比较完善的基础代码库，让你能直接调用，比如，针对电子邮件协议的SMTP库，针对桌面环境的GUI库，在这些已有的代码库的基础上开发，一个电子邮件客户端几天就能开发出来。 Python就为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作“内置电池（batteries included）”。用Python开发，许多功能不必从零编写，直接使用现成的即可。 除了内置的库外，Python还有大量的第三方库，也就是别人开发的，供你直接使用的东西。当然，如果你开发的代码通过很好的封装，也可以作为第三方库给别人使用。 许多大型网站就是用Python开发的，例如YouTube、Instagram，还有国内的豆瓣。很多大公司，包括Google、Yahoo等，甚至NASA（美国航空航天局）都大量地使用Python。 龟叔给Python的定位是“优雅”、“明确”、“简单”，所以Python程序看上去总是简单易懂，初学者学Python，不但入门容易，而且将来深入下去，可以编写那些非常非常复杂的程序。 总的来说，Python的哲学就是简单优雅，尽量写容易看明白的代码，尽量写少的代码。如果一个资深程序员向你炫耀他写的晦涩难懂、动不动就几万行的代码，你可以尽情地嘲笑他。 那Python适合开发哪些类型的应用呢？ 首选是网络应用，包括网站、后台服务等等； 其次是许多日常需要的小工具，包括系统管理员需要的脚本任务等等； 另外就是把其他语言开发的程序再包装起来，方便使用。 最后说说Python的缺点。 任何编程语言都有缺点，Python也不例外。优点说过了，那Python有哪些缺点呢？ 第一个缺点就是运行速度慢，和C程序相比非常慢，因为Python是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C程序是运行前直接编译成CPU能执行的机器码，所以非常快。 但是大量的应用程序不需要这么快的运行速度，因为用户根本感觉不出来。例如开发一个下载MP3的网络应用程序，C程序的运行时间需要0.001秒，而Python程序的运行时间需要0.1秒，慢了100倍，但由于网络更慢，需要等待1秒，你想，用户能感觉到1.001秒和1.1秒的区别吗？这就好比F1赛车和普通的出租车在北京三环路上行驶的道理一样，虽然F1赛车理论时速高达400公里，但由于三环路堵车的时速只有20公里，因此，作为乘客，你感觉的时速永远是20公里。 不要在意程序运行速度 第二个缺点就是代码不能加密。如果要发布你的Python程序，实际上就是发布源代码，这一点跟C语言不同，C语言不用发布源代码，只需要把编译后的机器码（也就是你在Windows上常见的xxx.exe文件）发布出去。要从机器码反推出C代码是不可能的，所以，凡是编译型的语言，都没有这个问题，而解释型的语言，则必须把源码发布出去。 这个缺点仅限于你要编写的软件需要卖给别人挣钱的时候。好消息是目前的互联网时代，靠卖软件授权的商业模式越来越少了，靠网站和移动应用卖服务的模式越来越多了，后一种模式不需要把源码给别人。 再说了，现在如火如荼的开源运动和互联网自由开放的精神是一致的，互联网上有无数非常优秀的像Linux一样的开源代码，我们千万不要高估自己写的代码真的有非常大的“商业价值”。那些大公司的代码不愿意开放的更重要的原因是代码写得太烂了，一旦开源，就没人敢用他们的产品了。 哪有功夫破解你的烂代码 当然，Python还有其他若干小缺点，请自行忽略，就不一一列举了。 注：此段简介来自于廖雪峰老师的教程 字符串和编码字符编码目前使用的编码方式有：ASCII码（一个字节）、Unicode码（两个字节）、UTF-8码（可变长的编码） 我们已经知道了，字符串也是一种数据类型，但是，字符串比较特殊的是还有一个编码问题。 因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295。 由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。 但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。 你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。 因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。 Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。 现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。 字母A用ASCII编码是十进制的65，二进制的01000001； 字符0用ASCII编码是十进制的48，二进制的00110000，注意字符&#39;0&#39;和整数0是不同的； 汉字中已经超出了ASCII编码的范围，用Unicode编码是十进制的20013，二进制的01001110 00101101。 你可以猜测，如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000 01000001。 新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。 所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间： 字符 ASCII Unicode UTF-8 A 01000001 00000000 01000001 01000001 中 x 01001110 00101101 11100100 10111000 10101101 UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。 Python的字符串在最新的Python3中字符串是以Unicode编码的，即其支持多语言。 对于单个字符的编码，Python提供了ord（）函数获取字符的整数表示，chr（）函数把编码转换为相应的字符。 &gt;&gt;&gt; ord(&apos;A&apos;) 65 &gt;&gt;&gt; ord(&apos;中&apos;) 20013 &gt;&gt;&gt; chr(66) &apos;B&apos; &gt;&gt;&gt; chr(25991) &apos;文&apos; 如果知道字符的整数编码，则可以用十六进制写str &gt;&gt;&gt; &apos;\u4e2d\u6587&apos; &apos;中文&apos; 由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。 Python对bytes类型的数据用带b前缀的单引号或双引号表示： x = b&apos;ABC&apos; 要注意区分&#39;ABC&#39;和b&#39;ABC&#39;，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。 以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如： &gt;&gt;&gt; &apos;ABC&apos;.encode(&apos;ascii&apos;) b&apos;ABC&apos; &gt;&gt;&gt; &apos;中文&apos;.encode(&apos;utf-8&apos;) b&apos;\xe4\xb8\xad\xe6\x96\x87&apos; &gt;&gt;&gt; &apos;中文&apos;.encode(&apos;ascii&apos;) Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; UnicodeEncodeError: &apos;ascii&apos; codec can&apos;t encode characters in position 0-1: ordinal not in range(128) 纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。 在bytes中，无法显示为ASCII字符的字节，用\x##显示。 反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法： &gt;&gt;&gt; b&apos;ABC&apos;.decode(&apos;ascii&apos;) &apos;ABC&apos; &gt;&gt;&gt; b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;.decode(&apos;utf-8&apos;) &apos;中文&apos; 要计算str包含多少个字符，可以用len()函数，当然，如果换成bytes则是计算的字节数。 由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行： #!/usr/bin/env python3 # -*- coding: utf-8 -*- 第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释； 第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。 申明了UTF-8编码并不意味着你的.py文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用UTF-8 without BOM编码： 格式化在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下： &gt;&gt;&gt; &apos;Hello, %s&apos; % &apos;world&apos; &apos;Hello, world&apos; &gt;&gt;&gt; &apos;Hi, %s, you have $%d.&apos; % (&apos;Michael&apos;, 1000000) &apos;Hi, Michael, you have $1000000.&apos; 你可能猜到了，%运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。 常见的占位符有： %d 整数 %f 浮点数 %s 字符串 %x 十六进制整数 其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数： &gt;&gt;&gt; &apos;%2d-%02d&apos; % (3, 1) &apos; 3-01&apos; &gt;&gt;&gt; &apos;%.2f&apos; % 3.1415926 &apos;3.14&apos; 如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串： &gt;&gt;&gt; &apos;Age: %s. Gender: %s&apos; % (25, True) &apos;Age: 25. Gender: True&apos; 如果%是一个普通字符，则使用%%来表示% 总结常用的三种编码方式： ASCII Unicode UTF-8 字符串与单个字符与编码的转换： （对于bytes类型的数据用带b前缀的单引号或双引号表示。例如：x = b&#39;ABC&#39;） 单个字符： ord() 函数把单个字符转换为字符的整数表示 &gt;&gt;&gt; ord(&apos;A&apos;) 65 chr() 函数把编码转换成对应的字符 &gt;&gt;&gt; chr(25991) &apos;文&apos; 字符串 encode()把str编码为指定的bytes（如：ASCII、UTF-8等） &gt;&gt;&gt; &apos;ABC&apos;.encode(&apos;ascii&apos;) b&apos;ABC&apos; &gt;&gt;&gt; &apos;中文&apos;.encode(&apos;utf-8&apos;) b&apos;\xe4\xb8\xad\xe6\x96\x87&apos; decode()把bytes数据转换成字符串 &gt;&gt;&gt; b&apos;ABC&apos;.decode(&apos;ascii&apos;) &apos;ABC&apos; &gt;&gt;&gt; b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;.decode(&apos;utf-8&apos;) &apos;中文&apos; 格式化 与c一致，在不知道用%什么的时候直接用%s即可。 最后再次注：本文摘取自 廖雪峰老师的Python教程]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派学习-I2c通信]]></title>
    <url>%2F2017%2F05%2F06%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AD%A6%E4%B9%A0-I2c%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[前言由于之前参加了学校的飞兆杯的比赛，题目是循迹小车，由于缺乏对于ldc1314芯片使用知识以及个人的能力原因，项目并没有做出来，但是还是学习了很多东西的。 其中以树莓派的I2C通信为最。 一、I2C简介I2C（Inter－Integrated Circuit）总线是由PHILIPS公司开发的两线式串行总线，用于连接微控制器及其外围设备。是微电子通信控制领域广泛采用的一种总线标准。它是同步通信的一种特殊形式，具有接口线少，控制方式简单，器件封装形式小，通信速率较高等优点。I2C 总线支持任何IC 生产工艺(CMOS、双极型）。通过串行数据（SDA）线和串行时钟 （SCL）线在连接到总线的器件间传递信息。每个器件都有一个唯一的地址识别（无论是微控制器——MCU、LCD 驱动器、存储器或键盘接口），而且都可以作为一个发送器或接收器（由器件的功能决定）。LCD 驱动器只能作为接收器，而存储器则既可以接收又可以发送数据。除了发送器和接收器外，器件在执行数据传输时也可以被看作是主机或从机（见表1）。主机是初始化总线的数据传输并产生允许传输的时钟信号的器件。此时，任何被寻址的器件都被认为是从机。 详见 百度百科-I2C总线 二、配置I2C接口，读取i2c设备的地址1、可以通过raspi-config配置工具配置使能I2C，或者通过编辑/boot/config.txt文件，加入一下一行内容： dtparam=i2c1=on dtparam=i2c_arm=on 2、安装I2C库和工具 $sudo apt-get install i2c-tools 3、当连接上I2C设备后，可以通过以下命令查看 $sudo i2cdetect -y -a 1 其中2a就是我们的ldc1314模块的i2c通信地址 三、对i2c设备寄存器的读写1、设备所有数据的读出sudo i2cdump -y 1 0x2a -y 代表取消用户交互过程，直接执行命令 1 代表I2C设备号 0x2a 代表I2C设备地址 该命令会到处0x00到0xFF地址范围内的所有数据，如图所示 2、数据的写入使用sudo i2cset -y 1 0x2a 0x1a 0x55即可向设备地址为0x2a的0x1a寄存器地址写入0x55 -y 代表取消用户交互过程，直接执行命令 1 代表I2C设备号 0x2a 代表I2C设备地址 0x1a 代表寄存器地址 0x55 代表向寄存器写入的数据 3、寄存器数据读出sudo i2cget -y 1 0x2a 0x1a 即可读出总线地址为0x2a设备的0x1a寄存器地址的数据 -y 代表取消用户交互过程，直接执行命令 1 代表I2C设备号 0x2a 代表I2C设备地址 0x1a 代表寄存器地址 4、对16位数据的读 在基本的命令后加上 w 即可实现 四、I2C编程因为使用树莓派我一直使用的语言是Python，故i2c编程只学到了Python 首先需要安装smbus库 sudo apt-get install python-smbus 示例代码如下 import smbus import time bus = smbus.SMBus(1) addr=0x2a recount_th0=0x1a # 对8位数据的读写 data=bus.read_byte_data(address,recount_th0) print data bus.write_byte_data(address,recount_th0,0x99) #对16位数据的读写 data=bus.read_word_data(address,recount_th0) print data bus.write_word_data(address,recount_th0,0x01d6) 注：bus = smbus.SMBus(1) 在树莓派版本2中，I2C设备位于/dev/I2C-1，所以此处的编号为1 python封装SMBUS操作函数具体代码请查看：https://github.com/bivab/smbus-cffi 五、速率相关1、查看I2C设备的速率sudo cat /sys/module/i2c_bcm2708/parameters/baudrate 默认的I2C速度为100KHz，对于多数I2C设备而言100KHz并不算快，但是对于个别的I2C设备而言100KZH还是太快了，那么也可以修改I2C的速率使得通信更稳定。 ##2、修改速率 ## 进入/etc/modprobe.d 目录，并在该目录下新建一个costom.conf文件，在该文件中插入options i2c_bcm2708 baudrate=32000，32000便为新的I2C速率，最后请重启系统。 cd /etc/modprobe.d #进入/etc/modprobe.d 目录 sudo nano custom.conf #在该目录新建一个名为custom.conf文件，并插入以下内容 #options i2c_bcm2708 baudrate=32000 sudo reboot #重启系统 六、参考资料树莓派入门教程——I2C Tools的安装和使用 树莓派与i2c设备的通信 树莓派学习笔记——I2C设备装入和速率设置 树莓派系列教程11：I2C编程]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>树莓派</tag>
        <tag>I2C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Hexo+GitHub Pages+独立域名 搭建博客详细教程]]></title>
    <url>%2F2017%2F03%2F29%2F%E5%9F%BA%E4%BA%8EHexo%2BGitHub%20Pages%2B%E7%8B%AC%E7%AB%8B%E5%9F%9F%E5%90%8D%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[一、摘要这是一篇利用GitHub Pages以及Hexo以及自己的独立域名来搭建自己的个人博客。 本文参考多篇文章（具体参看文章最后）并记录了过程中遇到的问题以及解决方案！ 此博客用于以后需要备用，并为其他人提供指导。 二、系统环境配置我们需要以下环境： Windows 10 Node.js Git 安装node.js 下载Node.js在 Windows 环境下安装 Node.js 非常简单，仅须到官网下载安装文件并执行即可完成安装。 安装Git 下载Git同样一路next即可！ · 安装教程： 如何在Windows下安装Git 三、安装HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 在任意盘新建hexo文件夹并右键，选择Bit Bash Here，如图： 然后输入安装hexo命令 $ npm install -g hexo-cli 接下来我们对hexo 进行初始化 $ hexo init 然后执行以下命令，系依赖包统会自动根据package.json文件中dependence的排位置安装所有的 $ npm install然后生成部署文件，启动本地服务 $ hexo g #或者hexo generate $ hexo s #或者hexo server 之后再http：//localhost：4000/ 查看 hexo的几个常用命令 hexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹 hexo server (hexo s) 启动本地web服务，用于博客的预览 hexo deploy (hexo d) 部署博客到远端服务器 hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 可以简写为 $ hexo n == hexo new $ hexo g == hexo generate $ hexo s == hexo server $ hexo d == hexo deploy 其实就是单词的首字母 以后新建文章或者修改，可以先在本地预览之后进行部署 四、GitHub Pages设置GitHub的优点GitHub是基于git实现的代码托管。git可能是目前最好用的版本控制系统了，非常受欢迎。 GitHub可以免费使用，并且快速稳定。 Github上面的世界很精彩，用久了你的眼界会开阔很多。 什么是GitHub Pages？Github Pages可以被认为是用户编写的、托管在github上的静态网页。GitHub Pages 本用于介绍托管在GitHub的项目，不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。 为什么使用GitHub Pages可以绑定你的域名(但只能绑定一个)。 简单快捷，使用Github Pages可以为你提供一个免费的服务器，免去了自己搭建服务器和写数据库的麻烦. 五、相关操作注册GitHub账号在创建博客之前，当然必须有GitHub的帐号，该帐号将用来创建项目，默认的域名username.github.com/projectName中的username也要用到这个帐号。（请记住username，之后会多次用到） 注意：下面涉及到的一些命令凡是更用户名和项目名有关的一律会用这里的username和projectName代替，注意替换 访问：http://www.github.com/，注册你的username和邮箱，邮箱十分重要，GitHub上很多通知都是通过邮箱的。比如你的主页上传并构建成功会通过邮箱通知，更重要的是，如果构建失败的话也会在邮件中说明原因。 创建项目仓库在创建博客之前，还需要用已有的帐号创建一个项目，上面那个链接的projectName将是这里即将创建的项目名称。 在Git中，项目被称为仓库(Repository)，仓库顾名思义，当然可以包含代码或者非代码。将来我们的网页或者模板实际上都是保存在这个仓库中的。 登录后，访问https://github.com/new，创建仓库如下图： 每个帐号只能有一个仓库来存放个人主页，而且仓库的名字必须是username/username.github.io，这是特殊的命名约定。你可以通过http://username.github.io 来访问你的个人主页。 创建了仓库后，我们就需要管理它，无论是管理本地仓库还是远程仓库都需要Git客户端；Git客户端实际上十分强大，它本身就可以offline的创建本地仓库，而本地仓库和远程仓库之间的同步也是通过Git客户端完成的。 配置SSH上传文件需要配置ssh key，不然无法上传。首先先检查一下本地是否已经存在ssh key,在Git Bash输入以下指令（任意位置点击鼠标右键），检查是否已经存在了SSH keys。 $ ls -al ~/.ssh 如果不存在就没关系，存在就删除其中的所有文件 设置你的那么和email（如果你安装git时已经有了这步操作就跳过，name可以随意，但最好设置成你的github的name防止遗忘。邮箱与你的github邮箱没什么关系，但是最好写为同一个，好记住） $ git config --global user.name &quot;name&quot; $ git config --global user.email &quot;&lt;your email&gt;&quot; 生成ssh密钥输入以下指令（邮箱就是你注册Github时候的邮箱）后，回车： $ ssh-keygen -t rsa -C “XXXXX@qq.com” 一路回车就可以了，如果设置了密码就记住。 这一步在~/.ssh/下生成了两个文件id_rsa 和 id_rsa.pub 获取key$ cat ~/.ssh/id_rsa.pub 然后拷贝key（key是以ssr（应该是这个开头的）开头 你的邮箱结尾的一长串字符。 在GitHub上添加SSH密钥在https://github.com/settings/keys下 add new ssh key title可随意填写，key就是我们拷贝的key 接下来测试一下是否配置正确。 输入一下命令： $ ssh git@github.com 成功后大概会出现一下内容：（可能会有部分不一致） The authenticity of host &apos;github.com (192.30.252.128)&apos; can&apos;t be established. RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added &apos;github.com,192.30.252.128&apos; (RSA) to the list of known hosts. Hi git-xuhao! You&apos;ve successfully authenticated, but GitHub does not provide shell access. Connection to github.com closed. 六、部署到GitHub配置_config.yml编辑 你所建立的hexo文件夹中_config.yml（用记事本打开）修改deployment部分。 # Deployment ## Docs: https://hexo.io/docs/deployment.html # ssh://git@github.com/Asuna520/Asuna520.github.io deploy: type: git repo: ssh://git@github.com/Asuna520/Asuna520.github.io branch: master 自行替换成你的GitHub的名称。注意：每个：后面必须有一个空格！！！ 安装Git包$ npm install hexo-deployer-git --save 部署到GitHub上$ hexo deploy 现在我们可以通过访问 http://git-xuhao.github.io/ 来访问我们自己的博客啦,可以看到我们的博客已成功搭建，接下来就是一些主题的优化和配置呢。 ### 配置文件的相关说明 # Hexo Configuration ## Docs: http://hexo.io/docs/configuration.html ## Source: https://github.com/hexojs/hexo/ # Site 这下面的几项配置都很简单，你看我的博客就知道分别是什么意思 title: blog name #博客名 subtitle: Goals determine what you are going to be #副标题 description: Goals determine what you are going to be #用于搜索，没有直观表现 author: huangjunhui #作者 language: zh-CN #语言 timezone: #时区，此处不填写，hexo会以你目前电脑的时区为默认值 # URL 暂不配置，使用默认值 ## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos; url: http://yoursite.com root: / permalink: :year/:month/:day/:title/ permalink_defaults: # Directory 暂不配置，使用默认值 source_dir: source public_dir: public tag_dir: tags archive_dir: archives category_dir: categories code_dir: downloads/code i18n_dir: :lang skip_render: # Writing 文章布局等，使用默认值 new_post_name: :title.md # File name of new posts default_layout: post titlecase: false # Transform title into titlecase external_link: true # Open external links in new tab filename_case: 0 render_drafts: false post_asset_folder: false relative_link: false future: true highlight: enable: true line_number: true tab_replace: # Category &amp; Tag 暂不配置，使用默认值 default_category: uncategorized category_map: tag_map: # Date / Time format 时间格式，使用默认值 ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http://momentjs.com/docs/#/displaying/format/ date_format: YYYY-MM-DD time_format: HH:mm:ss # Pagination ## Set per_page to 0 to disable pagination per_page: 10 #每页显示的文章数，0表示不分页 pagination_dir: page # Extensions 插件配置，暂时不配置 ## Plugins: http://hexo.io/plugins/ ## Themes: http://hexo.io/themes/ plugins: - hexo-generator-feed theme: light #使用的主题 feed: #之后配置rss会用，此处先不配置这个 type: atom path: atom.xml limit: 20 # Deployment 用于部署到github，之前已经配置过 ## Docs: http://hexo.io/docs/deployment.html deploy: type: git repo: ssh://git@github.com/Asuna520/Asuna520.github.io branch: master 七、如何添加一篇文章新建一篇博文可通过以下的命令 $ hexo new &quot;name&quot; 其中name为博文的名字，建立完成之后，可以在./source/_posts文件夹下发现我们刚刚建立的 name.md文件。使用你熟悉的编辑器打开，便可以进行博文的撰写。博文支持MarkDown语法的编写，下面是一个示例文件的内容（推荐使用MarkDown）（使用MarkDown时需要安装awesomium_v1.6.6_sdk_win)MarkDown界面如下： --- title: name date: 2016-04-06 10:34:21 permalink: （url中显示的标题） tags: - 开始 - 日志 categories: - 日志 --- Hello world，Test！！ 博文写好之后，在每次部署前，需要将博客生成静态文件 $ hexo g 生成之后进行部署 $ hexo d 然后打开我们的博客 http://Asuna520.github.io/ 已经可以看到刚刚新建的博文。 八、主题相关你会发现你预览的博客会很大众化，你想让你的博客与众不同？吸引更多的关注？ 可以参考知乎的主题推荐： 有哪些好看Hexo主题 我使用的是第一个next主题，具体相关操作，更多关于主题的设置请自行查阅相关文档，当然如果你认识我，也可以联系我进行询问。 九、专属域名的绑定这时候，你会发现你的域名不怎么好使用，你想要一个属于自己的独特的域名。 恩，首先，你需要去买一个域名。（推荐阿里云 .xyz的域名 第一年只需要6元，而且.xyz很有潜力，谷歌母公司也是使用的.xyz域名哦） 进入阿里云,选择解析 按照图片所示添加解析，其中ip地址，以及其他相关内容全部换成自己的 ip地址 可以通过为192.30.252.154 和192.30.252.153这两个固定ip！（图片由于自己一开始使用时，没注意，所以ip错了。。。懒得改了） 最后，在source中添加文件 CHAME 不带有任何后缀！！！ 用记事本打开之后，加入你自己的域名xxxxx.xyz 不需要www也不需要http的前缀！！！！ 重新部署一下！ 恭喜，过一会儿就可以通过你的域名看到你的博客啦12345678910# 十、总结 #大致过程基本上就是这样了，其中个别步骤，或者部分细节性问题没有赘述，有问题请自行百度或者联系我~~~作为一个程序员一定要有自己独立解决问题的能力哦~~~记住Google与你同在 加油！！！ 本文主要部分来自于：基于Hexo+GitHub Pages 搭建个人博客教程]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
